MyBatis中#和$区别:
	前者为占位符，后者为拼接.

JSP的优缺点介绍:
	什么是JSP？JSP可用一种简单易懂的等式表示为：HTML+Java=JSP
	jsp的优点是：
	1.一次编写，到处运行。由于JSP/Servlet都是基于Java的，所以它们也有Java语言的最大优点——平台无关性，
	也就是所谓的“一次编写，随处运行
	2.系统的多平台支持。基本上可以在所有平台上的任意环境中开发，在任意环境中进行系统部署
	3.强大的可伸缩性。从只有一个小的Jar文件就可以运行Servlet/JSP
	4.多样化和功能强大的开发工具支持
	jsp的缺点是：
	1.Java的一些优势正是它致命的问题所在。正是由于为了跨平台的功能，为了极度的伸缩能力，
	所以极大的增加了产品的复杂性。
	2.Java的运行速度是用class常驻内存来完成的，所以它在一些情况下所使用的内存比起用户数量来说确实是
	“最低性能价格比”了。从另一方面，它还需要硬盘空间来储存一系列的.java文件和.class文件，
	以及对应的版本文件。

什么是构造方法:
	与类同名，没有返回值类型，完成对象的初始化功能，类里面如果不写构造方法，也有一个默认的无参构造方法，
	一旦定义了构造方法，则默认的构造方法将移除.

String类里面的常用API:
	indexof()，查找一个字符串中，第一次出现指定字符串的位置
	subString()，返回一个新字符串，它是此字符串的一个子字符串，该字符串始于指定索引处的字符，
	一致到字符串末尾
	equals()，比较两个对象的值是否相等
	toString，
	trim()
	split()
	length()
	charAt()
	valueOf()
	toLowercase()
	toUppercase()

forEach和for循环的区别:
	forEach(增强for循环)适用于循环次数未知，一般用来遍历.for循环一定是知道循环次数，包含循环三要素.

数组和集合的区别:
	数组固定长度，下标从0开始，数组中存储的元素是同一类型的线性表结构.
	集合的长度是可动态扩展的，没有固定长度，可以存储多种数据类型。
             
什么是关系型数据库:
	Mysql/oracle/SqlServer 采用了关系模型来组织的数据库，以行和列来存储数据.

非关系型数据库(NoSQL):
	MongDB/redis(缓存) 分布式系统中,不提供事务处理,用键值对存储数据

对数据库的优化该怎么处理: 
	1.建库建表时:建立适当的索引.
 	2.建立合适的约束.
    3.建立主键和外键的关联.
 	4.字段类型的合适选择.
 	5.单表不要有太多字段，建议不超过20个.
 	6.尽量不要用select *查询数据.
 	7.尽量避免在where子句中对字段进行null判断.
 	8.对于要查询的字段，可以创建视图
 					 
ArrayList是不是线程安全的:
	不是线程安全的,会出现线程安全问题的地方就在于它的扩容机制1:增加元素，
	2:扩容数组长度,在增加元素的过程中elementData[size++]=e;
	添加元素时如果同时两个线程赋值就会出现线程安全问题.

数据库索引实现的原理:
	索引是一种数据结构,索引的数据结构是二叉树中的B+树

什么是GC:      
	GC是java中特有的垃圾回收机制,回收java虚拟机中没有被引用的对象.

类加载的过程:
	java中的类在jvm虚拟机中加载,把.java文件编译成.class字节码文件,然后运行字节码文件.
	由ClassLoder中的loadClass方法初始化.

字节流和字符流的区别:
	1.以Stream结尾的都是字节流，以reader和writer结尾的都是字符流.
	2.读写的时候字节流是按字节读写.字符流是有缓冲区的概念,在读写文件需要对内容按行处理,
	一般选择字符流.只是读写文件,和文件内容无关的时候用字节流(如音频，视频，图片等文件)
				 
jdk版本特性:
	1.5新增泛型,自动拆装箱
	1.6新增console的开发控制台程序
	1.7新增Switch case中的表达式可以使用String类型
	1.8新增了Lambda表达式.

Spring的bean生命周期:
	1:Spring启动,启动并加载需要被Spring管理的bean，进行bean的初始化.
	2:bean实例化后,将bean的引入和值注入到bean的属性中.
	3:bean准备就绪后,可以被程序使用,它们将一直保存在应用上下文中,直到上下文销毁.(setApplicationContext)

Spring中的bean的作用域:
	singleton:SpringIoc容器只会创建改bean唯一实例.
	prototype:每次调用getBean都创建一个实例.
	request:每次Http请求都会产生一个新的bean.
	session:每次会话创建一个实例.
	global：session:全局的HttpSession中,容器会返回该bean的同一个实例.
					  
SSM框架的理解:
	Spring:轻量级java应用开发框架,提供高内聚低耦合的开发结构,能整个多个其他框架.
      SpringMVC：Spring框架子模块,它更多的提供是MVC的架构模式. 
	      Model：处理实际业务逻辑的模块.
	      controller：控制器.实现业务逻辑和前端的分发工作.
	      view：前端视图,具体是展示页面.
	这样的好处是把持久层,展示层,业务层,分开架构,使开发效率更高,结构也更加清晰.
      MyBatis：是java中的持久层框架,它支持定制化sql存储过程及高级映射,底层就是JDBC,
	但是又避免了JDBC几乎所有的手动设置参数及获取结果集.mybatis可以使用简单的xml
	或注解来配置和映射JDBC的接口.

线程的生命周期:
	新建，就绪，启动，阻塞，死亡.

list set map集合的区别:
	list,set实现了collection接口.
		list有序，可重复.可以允许多个null值
		set无序,不可重复.只能允许一个null值
	map以 key-value键值对形式存储数据,key不可重复,通过key找到value.
	可以随意拥有多个null值，但只能有一个null健

cookies和session的区别:
	会话机制
	cookies:
	位置：数据存放在客户的浏览器上
	数据量：保存的数据不会超过4k
	安全性：在浏览器上可以设置权限
	时间上：是浏览器关闭口就结束此次会话
	session:
	位置：数据存放在服务器上
	数据量：session没有限制
	安全性：是没办法删除
	时间上：默认30分钟，一个是从配置文件tomcat下面的server.xml文件中可以修改
	还可以用setMaxlnactive（）方法设置

request对象主要方法有那些？:
	setAttribute(name);设置名字为name的request参数值
	getAttribute(name);返回名字为name的request参数值
	getCoolies();返回客户端的所有cookies对象，返回的结果一个cookies的数组
	getHeader();获得Http协议中定义的文件消息头信息

XML的解析方式有几种:
	DOM解析：
	dom树解析，把XML文件转换为一个包含其所有内容的树，全部加载执行，并可以对树进行遍历，查找方便快捷
	内存开销比较大，性能低
	SAX解析：
	边执行边解析，数据不会在内存中储存对内存的要求较小，同时不便于对数据的查询操作

Servlet的生命周期:
	生命周期其实时就是从创建到销毁的一个过程
	通过init()方法进行初始化，调用service()方法来处理客户端的请求，调用destroy()方法来销毁(结束);
	最后servlet是由JVM的垃圾回收器进行回收的

JVM中的堆和栈的区别:
	堆里面存放的是new出来的对象和数组
	栈中存储的是成员变量和引用的地址
	栈中存储数据的特点是，先进后出，后进先出

String为什么是不能被继承的？:
	String是java中处理字符串的类，由fianl修饰的
	String类中的属性char的数组也是final修饰的
	String类除了不能被继承，String类型一旦定义了字符串的变量，也不能被修改
	String定义的变量称为常量

现在有一个字符串在程序中需要被修改怎么操作:
	StringBuffer和StringBuilder
	StringBuffer是线程安全的，
	StringBuilder是线程不安全的，但是执行没有线程问题的字符串是优先使用StringBuilder，执行效率快

final finally和finalize的区别:
	final是java中的关键字，中文意思是最终的
	由final修饰的类，不能被继承，final修饰的变量叫常量不能被修改，final修饰的方法，不能被重写
	finally是异常处理机制中的关键字，finally的代码块不管是否有异常发生，都会在return之前执行，
	一般是用作对资源关闭
	finalize是GC中的一个方法，调用了finalize之后建议垃圾回收尽快执行

int和integer的区别:
	int是8个基本类型中的整型数据类型
	integer是int类型的包装类，我们的java是面向对象开发语言，在程序开发中有时需要将8个基本数据类型当做
	对象处理，但是基本数据类型并不具备对象的特征（封装，继承，多态，抽象）所以就对应的出现了包装类，
	使基本数据类型具备了对象的特性，利于程序开发，把int类型转化为integer称为自动装箱，把integer
	类型转换为int类型称为自动拆箱

Statement和perparedStatement有什么区别:
	perparedStatement有一个预编译的过程，可以有效制止sql注入，部分字段可以用(?)代替，
	Statement没有编译，写sql语句时比较麻烦

JDBC连接数据库的步骤:
	1.注册驱动，class.forName(driver)
	2.获取连接，getConnection(url,uer,password)
	3.创建Statement对象，createStatement（）;
	4.执行sql语句,遍历结果集
	5.关闭连接

什么是数据库中的视图？
	1.在数据库中一张虚拟的表，不占内存
	2.对于数据主要起到查询作用，把不希望展示给别人看的内容保护起来，视图的关键字是Viwe，安全数据对立
	不占用内存空间

Spring框架中的IOC和AOP:
	1.IOC和AOP是Spring两大核心组件
	2.IOC是控制反转和依赖注入，控制反转把bean的对象通过反射机制动态的调用到需要到对象的类中
	通过new的对象形式，简化了程序开发的难度，依赖注入是将对象交给容器处理，通过配置文件里面相应的
	bean以及属性的设置，分配给你需要调用的这个类
	依赖注入主要有两种方式
	1.构造器注入
	2.sql注入

面向对象编程:
	把程序的所思所想用对象所具备的特性（属性和行为）把它用代码表现出来，属性私有化，行为（方法）
	公开化

面向过程编程C，C++:
	由程序的需求发展需要在方法中去不断的添加新的函数

AOP面向切面编程:
	面向切面能够将那些与业务无关，却为业务板块所共同调用逻辑或责任（事物处理，日志管理，权限控制等）
	封装起来，遍于减少系统的重复代码，降低区块间的偶和，只注重业务逻辑的代码实现

MyBatis中的核心组件:
	sqlSession
	sqlSessionFactory
	sqlSessionFactoryBudiler

SpringMVC的运行流程？:
	1.客户端浏览器发送请求到DispatcherServlet
	2.DispatcherServlet根据请求信息调用HandlerMapping解析请求对应的Controller
	3.解析到对应的Controller后，开始由适配器处理，根据对应处理业务逻辑的类进行匹配
	4.处理器处理完成后，会返回一个ModelAndView对象，Model返回的是数据对象，View是视图对象
	5.ViewResolve会根据逻辑view对象查找真正的view
	6.DispatcherServlet把返回的model数据传给view进行视图渲染，view连同数据一起返回给浏览器

SpringMVC的五大组件:
	DispatcherServlet	（前端映射器）
	HandlerMapping	（分发器）
	Controller		（控制器）
	ViewResolve		（视图解析器）
	ModelAndView	（处理适配器）

Spring中运用到了那些设计模式？:
	单例模式：
	一个类里面只有一个实例，根据业务逻辑的处理情况，又把单例模式又分为饿汉模式和懒汉模式
	工厂模式:
	使用工厂模式通过BeanFacotory，ApplicationContext创建bean对象
	适配器模式:
	Spring的AOP里的增强或通知（Advice）使用到了适配器模式

将一个类声明为Spring的bean的注解有那些？:
	@Autowired	（自动装配）
	@Component	（通用注解）
	@Repository	（持久层注解，主要用于数据库相关操作）
	@Service	（业务层注解，主要用于业务逻辑处理相关）
	@Controller	（对应SpringMVC的控制层，主要用于接收用户请求并调用Service层返回数据给前端页面）

Spting管理事物的方式有几种?:
	事物简单的来讲就是在操作数据的时候保证要么全部成功要么失败
	autocommit=0（开启）/1（关闭）   开启事务
	commit			    提交事务
	rollback			    回滚
	事物的4大特性：原子性，一致性，隔离性，持久性
	事物的隔离级别：
	1.默认隔离级别
	2.可能导致赃读，幻读，或不可重复读
	3.可以阻止赃读，但是幻读或不可重复读可能会发生
	4.可以阻止赃读和幻读，但是不可重复读可能会发生
	5.可以阻止赃读和幻读以及不可重复读

	1.编程式事物，在代码中硬编码（不推荐使用）
	2.声明式事物，在配置文件配置（推荐使用）

声明式事物又分2中:
	1.基于xml文件的声明式事务
	2.基于注解的声明式事务

双向链表和双向循环链表的区别:
	访问方式：
	双向链表，可以从任何节点开始任意的前后双向访问
	循环链表，可以从任何节点开始顺序向后访问到任意节点
	操作方式：
	双向链表，可以在当前节点前面或后面插入，可以删除前一个和后一个包括节点自己
	循环链表，只能在当前节点后面插入或删除

HashMap和Hashtable的区别？:
	Hashtable：底层数组+链表的实现，无论是key还是value都不能为null，线程是安全的，
	实现线程安全的方法是在修改数据的时候锁住整个Hashtable，效率低，初始容量是Size=11，
	扩容是newSize=oldSize*2+1
	map集合中的扩容加载因子是0.75

	HashMap：底层是数组+链表的实现，可以存储null建和null值，线程不安全的
	初始扩容是16，扩容是newSize*2，扩容针对HashMap，是原数组中的元素重新计算存放位置并重新插入

MyBatis的#和$区别？:
	#有预编译的过程
	$只是指代字符串

说下对反射的理解？:
	java中的反射是类的自我管理机制，可以实现不用new对象，而动态的在程序运行时，
	需要某个对象通过类去调用它的对象，class.forName

什么是序列化？什么是反序列化？:
	序列化是一种处理对象流的机制，就是将对象的内容进行流化，可以实现对流化的对象进行读写操作，
	也可将流化的对象用于网络间的传输，为了解决在对象进行读写操作时可能会引发的问题

什么是java的序列化:
	把Java对象转换为字节序列的过程.

什么是java反序列化:
	把字节序列恢复为Java对象的过程.

序列化的用途:
	1.把对象的字节序列永久保存在硬盘上，通常是存在一个文件中
	2.在网络上传送对象的字节序列

是否可以在实例方法中访问静态变量？:
	可以
	静态变量是static修饰的，又叫类变量，是属于类的成员，实例方法是属于对象的方法，静态变量
	随着类的加载而加载，在对象的实例方法加载时静态变量已经存在，所以可以访问

是否可以在静态方法中方法中访问实例变量？:
	不可以

重写和重载的区别？:
	重写发生在父子类中，是子类重写父类的方法，最大的特征是方法名相同，参数列表不同
	方法体不同，发生在运行期
	重载发生在同一个类中，方法名相同，参数列表不同，方法体不同，发生在编译期

说一下迭代器的工作原理:
	lterator底层就是for循化，调用了多个API方法，hasNext（），Objectnext（），remove（）
	访问一个容器对象的内容时不会暴露它的类部表示，支持容器的多种编译，为遍历不同的容器结构提供了统一的接口

对象的hashcode和equals方法的理解:
	hashcode方法和equals方法是object类的方法，每一个对象都有这两个方法，他们的作用都是
	用来对同一类型做比较，在实现特定需求的时候我们可以重写则两个方法
	equals方法和hashcode方法的通用协定
	如果两个对象相等（equale），那么必须有相同的hash值
	如果两个对象有相同的hash值，他们的对象不一定相等

抽象类是否必须要有抽象方法？:
	不一定必须要有抽象方法，但是有抽象方法的类，一定是抽象类（abstract）

如何确保一个集合不被修改？:
	Colletions.UnmodifiableList

并行和并发的区别？:
	并发是指多个事件在同一时间段执行，并行是多个事件在同一时间点执行

session的工作原理？:
	Http和浏览器和服务器通讯的一种无状态协议，为了保持客户端的状态，使用会话机制中的session，
	在服务器响应浏览器的时候生成一个唯一的session_id，将session_id传递给浏览器中的cooKie，
	根据session_id来判断用户的状态，session是保存在服务器中，如果浏览器意外关闭，服务器保存的session
	数据不会立即释放，默认保存时间为30分钟

如果浏览器中的cooKie被禁用，session还能使用吗?:	
	可以使用，需要在响应的url当中把session_id数据传递给客户端浏览器上，
	通过url重写，把session作为参数追加到原来url中，使后续的浏览器与服务器交互中携带session参数中

什么是sql注入？如何防止sql注入:
	sql注入是一种将sql代码添加到输入参数中，传递到sql服务器解析并执行的一种针对数据库的攻击手法
	获取id值，当id值为1时，传递参数-1 or 1=1
	web应用中尽量使用post请求，做正则判断把有潜在风险的sql注入字段，进行拦截，连接数据库时，用预编译
	的语句preparedStatement

集合追加尾部ArrayList和LinkedList谁快？:
	LinkedList追加元素快，因为ArrayList的扩容和缩容都是重写

	Node节点下有3个属性
	E item	本节点
	Node<E>next 上个节点
	Node<E>prev 下个节点

set为什么元素不能重复？说下对treeSet的理解:
	set元素必须定义equals方法以保证对象的唯一性，加入到set里面的元素必须定义自己的equals方法，
	当往set集合中添加新元素时，首先会遍历已经存在的set元素比较元素的hashcode
	treeSet底层实现是红黑树，是计算机中的一种计算结构，典型的用途就是实现关联数组，
	存储有序的数据
	红黑树的特点：自平衡二叉树
	1.每一个节点是黑色或者是红色
	2.根节点是黑色的
	3.每一个叶子节点是黑色的
	4.如果一个节点是红色的，则它的子节点必须是黑色的
	5.每个节点到叶子节点所经过的黑色节点的哥舒是一样的

什么是线程？:
	线程是程序执行的最小单元

什么是过滤器链？:
	过滤器是在javaweb项目中常用的用来拦截请求的一种规范，在web.xml文件中配置的 Filter(过滤器)
	配置了多个用来拦截请求的过滤器

数据库中聚合函数？:
	聚合函数是对一组数值执行运算，并返回单个值的方法
	求平均值 avg（）
	求最大值 max（）
	求最小值 min（）
	求和	  sum（）

mySql中4中连接方式: 
	左连接：
	指左边表中的数据为基准，若左表有数据，右表没数据则显示左表中的数据，右表显示为空，
	左连接的结果集包括left字句中指定的左表的所有行
	右连接：
	指右边表中的数据为基准，若右表有数据，左表没数据则显示右表中的数据，左表显示为空，
	右连接的结果集包括right字句中指定的右表的所有行
	内外连接：
	自连接：

数组的去重:
	distinct（）数据库中的去重和数组中的去重都是这个

什么是B/S架构:
	B/S架构就是Browser/Server也就是浏览器和服务器它的是建立在广域网的基础上的
	优点.
	1.因为B/C架构是具备通用性，所以开发成本较低
	2.因为不需要安装客户端，所以客户端步于要进行升级
	缺点.
	1.耗流量，每次都要加载全部的内容
	2.因为独立的客户端，所以无法实现个性化

什么是C/S架构:
	C/S架构就是Client/Server也就是客户端和服务器，它是建立在局域网的基础上的
	优点.
	1.客户端因为是独立设计，所以可以实现个性化
	2.因为客户端是独立开发的，所以有能力对客户端进行安全设计
	缺点.
	1.因为客户端是不需要重复安装所以客户可以不更新与升级，增加了维护成本
	2.因为需要开发客户端和服务器两套程序，所以开发成本增加

所知道网络协议有那些？各自都有那些特点:
	HTTP：
	1.支持客户端模式/服务器模式
	2.http协议是无状态协议，无状态协议对于事务处理没有记忆能力，缺少状态，意味着如果后续处理需要前面的信息，
	则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器步于要先前信息时它的应答的较快
	TCP：
	面向连接，传输可靠，传输大量数据，传输速度慢
	UDP：
	面向非连接，传输不可靠，传输少量数据，传输速度快

java都有那些开发模式:
	javaEE:
	java企业版，主要用于分布式的网络程序的开发
	javaSE:
	java标准版，主要用于桌面应用软件的编程
	javaME:
	是为机顶盒，移动电话和PDA之类嵌入式消费电子设备提供java语言平台，包括虚拟机和一系列标准化的javaAPI

java是否需要开发人员回收内存垃圾吗？:
	不需要，因为java有GC，GC就是垃圾回收机制

什么是数据结构？:
	数据结构是计算机存储，组织数据的方式，数据结构是指相互之间存在一种或多种特定关系的数据元素的集合

一个java类中包含那些内容？:
	包含变量和方法

Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。
(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet
(2)创建：通过调用servlet构造函数创建一个servlet对象
(3)初始化：调用init方法初始化
(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求
(5)卸载：调用destroy方法让servlet自己释放其占用的资源
	





